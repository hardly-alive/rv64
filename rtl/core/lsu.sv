module lsu 
    import riscv_pkg::*;
(
    // Inputs from Pipeline (EX/MEM)
    input  lsu_op_t     lsu_op_i,
    input  logic [63:0] addr_i,      // Generated by ALU (rs1 + imm)
    input  logic [63:0] store_data_i,// From rs2
    input  logic [63:0] load_data_i, // Raw data read from RAM

    // Outputs to Data Memory (RAM)
    output logic        mem_req_o,   // Valid Request
    output logic        mem_we_o,    // Write Enable (1=Write, 0=Read)
    output logic [63:0] mem_addr_o,
    output logic [63:0] mem_wdata_o,
    output logic [7:0]  mem_be_o,    // Byte Enable (Mask)

    // Output to Writeback (Formatted Load Data)
    output logic [63:0] result_o
);

    // 1. Memory Request Signals
    assign mem_req_o   = (lsu_op_i != LSU_NONE);
    assign mem_we_o    = (lsu_op_i >= LSU_SB); // SB, SH, SW, SD are writes
    assign mem_addr_o  = addr_i;

    // 2. Store Logic (Data Alignment & Masking)
    // We shift the data to the correct byte position based on address
    // Example: SB to address 0x1 writes to bits [15:8]
    always_comb begin
        mem_wdata_o = store_data_i; // Default (for SD)
        mem_be_o    = 8'b0000_0000;

        // Shift data to align with the address offset
        // (For simplicity in this step, we assume aligned accesses or handle shifting in RAM model.
        //  Real hardware would do: mem_wdata_o = store_data_i << (addr_i[2:0] * 8); )
        // Let's implement basic aligned logic for now:

        case (lsu_op_i)
            LSU_SB: begin
                mem_wdata_o = store_data_i << (addr_i[2:0] * 8);
                mem_be_o    = 8'b0000_0001 << addr_i[2:0];
            end
            LSU_SH: begin
                mem_wdata_o = store_data_i << (addr_i[2:0] * 8);
                mem_be_o    = 8'b0000_0011 << addr_i[2:0];
            end
            LSU_SW: begin
                mem_wdata_o = store_data_i << (addr_i[2:0] * 8);
                mem_be_o    = 8'b0000_1111 << addr_i[2:0];
            end
            LSU_SD: begin
                mem_wdata_o = store_data_i;
                mem_be_o    = 8'b1111_1111;
            end
            default: mem_be_o = 8'b0; // Loads don't write
        endcase
    end

    /* verilator lint_off UNUSED */
    logic [63:0] raw_shifted;
    /* verilator lint_on UNUSED */
    // Shift data down so the byte we want is at LSB
    assign raw_shifted = load_data_i >> (addr_i[2:0] * 8);

    always_comb begin
        result_o = load_data_i; // Default
        case (lsu_op_i)
            LSU_LB:  result_o = {{56{raw_shifted[7]}},  raw_shifted[7:0]};
            LSU_LBU: result_o = {56'b0,                 raw_shifted[7:0]};
            LSU_LH:  result_o = {{48{raw_shifted[15]}}, raw_shifted[15:0]};
            LSU_LHU: result_o = {48'b0,                 raw_shifted[15:0]};
            LSU_LW:  result_o = {{32{raw_shifted[31]}}, raw_shifted[31:0]};
            LSU_LWU: result_o = {32'b0,                 raw_shifted[31:0]};
            LSU_LD:  result_o = load_data_i; // 64-bit load
            default: result_o = 64'b0;
        endcase
    end

endmodule